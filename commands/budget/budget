#!/usr/bin/env python3

# import math
# ns = vars(math).copy()
# ns['__builtins__'] = None
# eval('cos(pi/3)', ns)

from collections import OrderedDict

def float_math(s):
    import math
    ns = vars(math).copy()
    ns['__builtins__'] = None
    return float(eval(s, ns))

class Budget:
    def __init__(self):
        self.budgets = []
        self.incomes = []
        self.tax = 0
        self.percents = []
        self.expenses = []

    def __repr__(self):
        from pprint import pformat
        s = {
                "incomes": self.incomes,
                "tax": self.tax,
                "percents": self.percents,
                "budgets": self.budgets,
                "expenses": self.expenses
        }
        return pformat(s)

    def parse_budget(budget, lines):
        for l in lines:
            l = l.strip().split(" ")
            if len(l) < 1:
                continue

            verb = l[0]
            l = l[1:]
            if verb == "in":
                if len(l) == 2:
                    place, amount = l
                else:
                    amount = l[0]
                budget.incomes.append(float_math(amount))
            elif verb == "tx":
                if len(l) == 2:
                    place, amount = l
                else:
                    amount = l[0]
                budget.tax += float_math(amount)
            elif verb == "bg":
                amount = "-1"
                if len(l) == 2:
                    place, amount = l
                else:
                    place = l[0]
                if amount[-1] == "%":
                    amount = amount[:-1]
                    budget.percents.append((place, float_math(amount)/100))
                else:
                    budget.budgets.append((place, float_math(amount)))
            elif verb == "ex":
                bg = "other"
                index = None
                for i in range(len(l)):
                    if l[i][0] == "@":
                        bg = l[i][1:]
                        index = i
                        break
                if index is not None:
                    l.pop(index)

                amount = float_math(l[-1])
                l = l[:-1]
                name = " ".join(l)
                budget.expenses.append((name, amount, bg))

        return budget

    def analyze(budget):
        total_income = sum(budget.incomes)
        spendable = total_income * (1-budget.tax)

        budget_totals = OrderedDict()
        for p in budget.percents:
            budget_totals[p[0]] = spendable*p[1]

        rent = 0
        for e in budget.expenses:
            if e[2] not in budget_totals:
                budget_totals[e[2]] = 0
            budget_totals[e[2]] += e[1]
            if e[0] == "rent":
                rent += e[1]

        leftover = spendable
        for b in budget_totals:
            repeat = 1
            if b == "weekly":
                repeat = 52
            if b == "monthly":
                repeat = 12
            leftover -= budget_totals[b]*repeat

        p = []
        p.append(("income", total_income))
        p.append(("taxes", budget.tax))
        p.append(("spendable", spendable))
        p.append(None)
        p.extend([(b, budget_totals[b]) for b in budget_totals])
        p.append(("rent", rent))
        p.append(None)
        p.append(("leftover", leftover))
        p.append(("monthly", leftover/12))
        p.append(("weekly", leftover/52))
        if "weekly" in budget_totals:
            p.append(("week", leftover/52+budget_totals["weekly"]))

        for line in p:
            if line is not None:
                print(("{:<10}{:>10,.2f}".format(line[0].capitalize(), line[1])))
            else:
                print("")

        return budget

def Run(args):
    sheet = args.sheet
    lines = []
    with open(sheet) as f:
        lines = f.readlines()
    budget = Budget().parse_budget(lines).analyze()
    return True

import argparse
def parseArgs():
    parser = argparse.ArgumentParser("budget")
    parser.add_argument("--debug", action="store_true")
    parser.add_argument("sheet", type=str)

    args = parser.parse_args()
    return args


if __name__ == "__main__":
    try:
        args = parseArgs()
        if not Run(args):
                print("Error")
    except KeyboardInterrupt:
        pass
